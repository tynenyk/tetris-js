# Tetris-JS

Тетрис - отличная игра, чтобы начать наше путешествие в разработке игр. Он содержит основные элементы игр и относительно прост в программировании. Тетромино представляют собой набор из четырех блоков, что делает графику немного проще, чем в большинстве игр.

# Структура проекта

Хорошо разделить код на несколько частей в проекте, даже если он не такой большой. JavaScript находится в четырех разных файлах:

<li><strong>constants.js</strong> - это место, где мы размещаем настройки и правила игры.</li>
<li><strong>board.js</strong> - для доски логики.</li>
<li><strong>piece.js</strong> - для кусок логики.</li>
<li><strong>main.js</strong> - имеет код для инициализации игры и общую игровую логику.</li>
<li><strong>index.html</strong> - порядок сценариев, которые мы добавляем в конце, очень важен.</li>
<li><strong>styles.css</strong> - все украшающие стили здесь.</li>
<li><strong>README.md</strong> - информационный файл, который является первой страницей в хранилище.</li>

# Размер и Стиль

Игровая доска состоит из 10 колонок и 20 рядов. Мы часто используем эти значения для обхода платы, чтобы добавить их в constants.js вместе с размером блоков:

```
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30;
```
Я предпочитаю использовать элемент canvas для графики.

```
<div class="grid">
  <canvas id="board" class="game-board"></canvas>
  <div class="right-column">
    <div>
      <h1>TETRIS</h1>
      <p>Score: <span id="score">0</span></p>
      <p>Lines: <span id="lines">0</span></p>
      <p>Level: <span id="level">0</span></p>
      <canvas id="next" class="next"></canvas>
    </div>
    <button onclick="play()" class="play-button">Play</button>
  </div>
</div>
```

Мы можем получить элемент canvas и его 2d-контекст в main.js и использовать константы для установки размера:

```
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

// Calculate size of canvas from constants.
ctx.canvas.width = COLS * BLOCK_SIZE;
ctx.canvas.height = ROWS * BLOCK_SIZE;

// Scale blocks
ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
```

Используя масштаб, мы всегда можем дать размер блоков как один (1) вместо необходимости везде вычислять с BLOCK_SIZE, что упрощает наш код.

# Стайлинг

Приятно, чтобы в нашей игре было ощущение 80-х. Press Start 2P - это растровый шрифт, основанный на дизайне шрифтов аркадных игр Namco 1980-х годов. Мы можем сослаться на него в <head> и добавить его в наши стили:
  
```
<link 
  href="https://fonts.googleapis.com/css?family=Press+Start+2P" 
  rel="stylesheet"
/>
```

Первый раздел в styles.css предназначен для шрифта в стиле аркады. Обратите внимание на использование CSS Grid и Flexbox для макета:

```
* {
  font-family: 'Press Start 2P', cursive;
}

.grid {
  display: grid;
  grid-template-columns: 320px 200px;
}

.right-column {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.game-board {
  border: solid 2px;
}

.play-button {
  background-color: #4caf50;
  font-size: 16px;
  padding: 15px 30px;
  cursor: pointer;
}
```

Теперь у нас есть стилизованный и готовый игровой контейнер, ожидающий кода.

# Доска

Доска в тетрисе состоит из ячеек, которые либо заняты, либо нет. Моей первой мыслью было представить ячейку с логическими значениями. Но мы можем добиться большего, используя цифры. Мы можем представить пустую ячейку с 0, а цвета с номерами 1–7.

Следующая концепция представляет строки и столбцы игрового поля. Мы можем использовать массив чисел для представления строки. А доска это массив строк. Другими словами, двумерный (2D) массив или то, что мы называем матрицей.

Давайте создадим функцию в board.js, которая возвращает пустую доску со всеми ячейками, установленными на ноль. Метод fill () пригодится здесь:

```
class Board {
  grid;
  
  // Reset the board when we start a new game.
  reset() {
    this.grid = this.getEmptyBoard();
  }
  
  // Get matrix filled with zeros.
  getEmptyBoard() {
    return Array.from(
      {length: ROWS}, () => Array(COLS).fill(0)
    );
  }
}
```

Мы можем вызвать эту функцию в main.js, когда нажимаем play:

```
let board = new Board();

function play() {
  board.reset();
  console.table(board.grid);
}
```

Используя console.table, мы видим представление платы в цифрах.
Координаты X и Y представляют ячейки доски. Теперь, когда у нас есть доска, давайте посмотрим на движущиеся части.

# Тетромино

Фигура в тетрисе - это фигура, состоящая из четырех блоков, которые движутся как единое целое. Их часто называют tetrominos и входят в семь различных образцов и цветов. Имена I, J, L, O, S, T и Z имеют сходство по форме.

Мы представляем J-тетромино в виде матрицы, где число два представляет цветные клетки. Мы добавляем ряд нулей, чтобы центр вращался:

```
[2, 0, 0],
[2, 2, 2],
[0, 0, 0];
```
Мы хотим, чтобы класс Piece знал свое положение на доске, какой у него цвет и как он выглядит. Таким образом, чтобы иметь возможность рисовать себя на доске, ему нужна ссылка на контекст холста.

Для начала мы можем жестко закодировать значения нашего куска:

```
class Piece {
  x;
  y;
  color;
  shape;
  ctx;
  
  constructor(ctx) {
    this.ctx = ctx;
    this.spawn();
  }
  
  spawn() {
    this.color = 'blue';
    this.shape = [
      [2, 0, 0], 
      [2, 2, 2], 
      [0, 0, 0]
    ];
    
    // Starting position.
    this.x = 3;
    this.y = 0;
  }
}
```
Чтобы нарисовать тетромино на доске, мы перебираем все ячейки фигуры. Если значение в ячейке больше нуля, мы окрашиваем этот блок.

```
draw() {
  this.ctx.fillStyle = this.color;
  this.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      // this.x, this.y gives the left upper position of the shape
      // x, y gives the position of the block in the shape
      // this.x + x is then the position of the block on the board
      if (value > 0) {
        this.ctx.fillRect(this.x + x, this.y + y, 1, 1);
      }
    });
  });
}
```

Доска отслеживает тетромино на доске, поэтому мы можем создать и нарисовать ее, когда нажимаем кнопку воспроизведения:

```
function play() {
  board = getEmptyBoard();
  let piece = new Piece(ctx);
  piece.draw();
  
  board.piece = piece;
}
```

# Ввод с клавиатуры

Нам нужно соединить события клавиатуры, чтобы переместить фигуру на доске. Функция перемещения изменяет переменную x или y текущей фигуры, чтобы изменить ее положение на доске.

```
move(p) {
  this.x = p.x;
  this.y = p.y;
}
```

# Перечисления

Далее мы сопоставляем ключи с кодами ключей в constants.js. Для этого было бы неплохо иметь перечисление
В JavaScript нет встроенных перечислений, поэтому давайте создадим их, создав объект со значениями:

```
const KEY = {
  LEFT: 37,
  RIGHT: 39,
  DOWN: 40
}
Object.freeze(KEY);
```
Const может вводить в заблуждение при работе с объектами и массивами и фактически не делает их неизменными. Чтобы достичь этого, мы можем использовать Object.freeze (). Несколько ошибок здесь:

<li>Чтобы это работало правильно, нам нужно использовать строгий режим.</li>
<li>Это работает только на один уровень ниже. Другими словами, если у нас есть массив или объект внутри нашего объекта, то это не замораживает их.</li>

# Объектные литералы

Чтобы сопоставить ключевые события с действиями, мы можем использовать поиск литералов объектов.

Нам нужны скобки, чтобы получить вычисляемые имена свойств, чтобы мы могли использовать наши константы. Это упрощенный пример того, как это работает:

```
const X = 'x';
const a = { [X]: 5 };
console.log(a.x); // 5
```


Мы хотим отправить текущее тетромино и вернуть его копию вместе с изменением координат. Для этого мы можем использовать оператор распространения, чтобы получить мелкую копию, а затем изменить координаты на желаемое положение.
Другими словами, в этом фрагменте кода происходит многое:

```
moves = {
  [KEY.LEFT]:  p => ({ ...p, x: p.x - 1 }),
  [KEY.RIGHT]: p => ({ ...p, x: p.x + 1 }),
  [KEY.UP]:    p => ({ ...p, y: p.y + 1 })
};
```

Который мы можем использовать с кодом ниже, чтобы получить новое состояние, не изменяя оригинальную часть. Это важно, потому что мы не всегда хотим переходить на новую должность.
```
const p = this.moves[event.key](this.piece);
```
Затем мы добавляем прослушиватель событий, который прослушивает события нажатия клавиш:

```
document.addEventListener('keydown', event => {
  if (moves[event.keyCode]) {  
    // Stop the event from bubbling.
    event.preventDefault();
    
    // Get new state of piece
    let p = moves[event.keyCode](board.piece);
    
    if (board.valid(p)) {    
      // If the move is valid, move the piece.
      board.piece.move(p);
      
      // Clear old position before drawing.
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
      
      board.piece.draw();
    }
  }
});
```
Теперь мы слушаем события клавиатуры, и если мы нажмем стрелки влево, вправо или вниз, то увидим движение фигуры.
У нас есть движение! Однако призрачные фигуры, проходящие сквозь стены, - это не то, чего мы хотим.

# Обнаружение столкновения

Тетрис не был бы особенно захватывающей игрой, если бы все блоки могли проходить друг через друга, или если стены и пол не останавливали их. Таким образом, вместо перемещения тетромино, мы сначала проверим потенциальные столкновения, а затем только переместим тетромино, если это безопасно. У нас есть несколько разных столкновений для рассмотрения.

У нас есть столкновение, когда тетромино:

<li>падает на пол</li>
<li>двигается влево или вправо в стену</li>
<li>попадает в блок на доске</li>
<li>вращается, и новое вращение попадает в стену или блок</li>


Мы уже определили потенциальную новую позицию для фигуры. Теперь мы можем добавить проверку правильности этой позиции, прежде чем перейти к ней. Чтобы проверить наличие столкновений, мы перебираем все пробелы в сетке, которые тетромино займет в своей потенциальной новой позиции.


Для этого лучше всего подходит метод массива every (). С его помощью мы можем проверить, все ли элементы массива проходят тесты, которые мы предоставляем. Мы вычисляем координаты каждого блока куска и проверяем, что это правильная позиция:

```
valid(p) {
  return p.shape.every((row, dy) => {
    return row.every((value, dx) => {
      let x = p.x + dx;
      let y = p.y + dy;
      return (
        this.isEmpty(value) ||
       (this.insideWalls(x) &&
        this.aboveFloor(y)
      );
    });
  });
}
```

Используя этот метод, прежде чем мы переместимся, мы обеспечим, чтобы мы не перемещались туда, куда не должны:

```
if (this.valid(p)) {
  this.piece.move(p);
}
```
Давайте попробуем снова выйти за пределы сетки.

Теперь, когда пол останавливает тетромино, мы можем добавить еще одно движение, называемое жестким падением. Нажатие пробела сбрасывает тетромино, пока оно не столкнется с чем-то. Это называется жесткой каплей. Нам также нужно добавить новое сопоставление клавиш и переместить:

```
const KEY = {  
  SPACE: 32,
  // ...
}

moves = {  
  [KEY.SPACE]: p => ({ ...p, y: p.y + 1 })
  // ...
};

// In EventListener
if (event.keyCode === KEY.SPACE) {
  // Hard drop
  while (board.valid(p)) {
    board.piece.move(p);   
    p = moves[KEY.DOWN](board.piece);
  }
}
```

# Вращение

Теперь мы можем двигаться, но было бы неинтересно, если мы не можем вращать кусок. Нам нужно вращать тетромино вокруг их центра.

```
// Transpose matrix, p is the Piece.
for (let y = 0; y < p.shape.length; ++y) {
  for (let x = 0; x < y; ++x) {
    [p.shape[x][y], p.shape[y][x]] = 
    [p.shape[y][x], p.shape[x][y]];
  }
}

// Reverse the order of the columns.
p.shape.forEach(row => row.reverse());
```

Мы можем добавить функцию, которая вращает форму. Ранее мы использовали оператор распространения для клонирования координат. В этом случае мы работаем с многоуровневым массивом, но оператор распространения копирует только один уровень глубиной. Остальное скопировано по ссылке.


Вместо этого я использую JSON.parse и JSON.stringify. Метод stringify () преобразует матрицу в строку JSON. Метод parse () анализирует строку JSON, снова возвращая нашу матрицу клону.

```
rotate(p){
  // Clone with JSON for immutability
  let clone = JSON.parse(JSON.stringify(p));
  
  // Do algorithm
  
  return clone;
}
```

Затем мы добавляем новое состояние для ArrowUp в board.js.

```
[KEY.UP]: (p) => this.rotate(p)
```
# Рандомизировать Тетромино


Чтобы иметь возможность получать разные виды фрагментов, нам нужно добавить немного рандомизации в наш код.
Следуя системе Super Rotation, мы можем взять первую позицию частей и добавить их к нашим константам вместе с цветами.

```
const COLORS = [  
  'cyan',
  'blue',
  'orange',
  'yellow',
  'green',
  'purple',
  'red'
];

const SHAPES = [  
  [
    [0, 0, 0, 0], 
    [1, 1, 1, 1],
    [0, 0, 0, 0], 
    [0, 0, 0, 0]
  ], 
  [
    [2, 0, 0],
    [2, 2, 2],
    [0, 0, 0]
  ],
  // And so on
];
```

Нам нужно рандомизировать индекс одного из них, чтобы выбрать один кусок. Чтобы получить случайное число, мы создаем функцию, которая использует длину массива.

```
randomizeTetrominoType(noOfTypes) {
  return Math.floor(Math.random() * noOfTypes);
}
```

С помощью этого метода мы можем получить случайный тип тетромино, когда мы порождаем, а затем установить его цвет и форму:

```
const typeId = this.randomizeTetrominoType(COLORS.length);
this.shape = SHAPES[typeId];
this.color = COLORS[typeId];
```

Если мы нажмем кнопку воспроизведения, на странице появятся фрагменты разных форм и цветов.

# Игровой цикл

Почти во всех играх есть одна основная функция, которая поддерживает игру, даже когда пользователь ничего не делает. Этот цикл запуска одной и той же основной функции снова и снова называется игровым циклом. В нашей игре нам нужен игровой цикл, который перемещает тетромино вниз по экрану.

<strong>RequestAnimationFrame</strong>

Чтобы создать наш игровой цикл, мы можем использовать requestAnimationFrame. Он сообщает браузеру, что мы хотим анимировать, и должен вызвать функцию для обновления анимации перед следующей перерисовкой. Другими словами, мы говорим браузеру: «В следующий раз, когда вы будете рисовать на экране, также запустите эту функцию, потому что я тоже хочу что-то нарисовать».

Способ анимации с помощью window.requestAnimationFrame () - создать функцию, которая рисует кадр, а затем перепланирует его сам. Если мы используем его внутри класса (в нашем случае это не так), нам нужно привязать вызов к этому, или он имеет объект окна в качестве контекста. Так как он не содержит функцию animate, мы получаем ошибку.

```
animate() {
  this.piece.draw();
  requestAnimationFrame(this.animate.bind(this));
}
```

Мы можем удалить все наши предыдущие вызовы draw () и вместо этого вызвать animate () из функции play (), чтобы запустить анимацию. Если мы попробуем нашу игру, она все равно будет работать как раньше.

# Таймер


Далее нам нужен таймер. Каждый раз, когда мы бросаем тетромино. На странице MDN есть пример, который мы можем изменить в соответствии с нашими потребностями.
Мы начинаем с создания объекта с необходимой нам информацией:

```
time = { start: 0, elapsed: 0, level: 1000 };
```

В игровом цикле мы обновляем наше игровое состояние на основе временного интервала, а затем выводим результат.

```
function animate(now = 0) {
  // Update elapsed time.  
  time.elapsed = now - time.start;
  
  // If elapsed time has passed time for current level  
  if (time.elapsed > time.level) {
  
    // Restart counting from now
    time.start = now;   
    
    this.drop();  
  }
  
  // Clear board before drawing new state.
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
  
  board.draw();  
  requestId = requestAnimationFrame(animate);
}
```

Далее, давайте посмотрим, что происходит, когда мы достигаем дна.

# Стоп-кадр

Когда мы больше не можем двигаться вниз, мы замораживаем кусок и порождаем новый. Давайте начнем с определения freeze (). Эта функция объединяет блоки tetromino с платой:

```
freeze() {
  this.piece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value > 0) {
        this.grid[y + this.piece.y][x + this.piece.x] = value;
      }
    });
  });
}
```

Мы пока ничего не видим, но, зарегистрировав представление доски, мы видим, что форма на доске.
Давайте добавим функцию, которая рисует доску:

```
drawBoard() {
  this.grid.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value > 0) {
        this.ctx.fillStyle = COLORS[value];
        this.ctx.fillRect(x, y, 1, 1);
      }
    });
  });
}
```

Теперь функция рисования выглядит так:

```
draw() {
  this.piece.draw();
  this.drawBoard();
}
```

Если мы запустим игру, мы увидим, что фигуры появляются.

Теперь, когда мы замораживаем части, нам нужно добавить новое обнаружение столкновений. На этот раз мы должны убедиться, что не столкнемся с замороженными тетромино на доске. Мы можем сделать это, проверив, что ячейка равна нулю. Добавьте это к действительному методу и отправьте на доске в качестве аргумента:

```
board[p.y + y][p.x + x] === 0;
```
Теперь, когда мы добавляем фигуры на доску, на ней быстро становится тесно. Мы должны что-то с этим сделать.

# Линия чистая

Чтобы продержаться дольше, нам нужно собрать тетромино в ряды блоков, которые охватывают весь ряд, в результате чего получается чистая линия. Когда вы это сделаете, ряд исчезнет, и те, что над ним, успокоятся.

Обнаружение сформированных линий так же просто, как проверка наличия нулей:

```
this.grid.forEach((row, y) => {

  // If every value is greater than 0.
  if (row.every(value => value > 0)) {
  
    // Remove the row.
    this.grid.splice(y, 1);
    
    // Add zero filled row at the top. 
    this.grid.unshift(Array(COLS).fill(0));
  } 
});
```
Мы можем добавить вызов этой функции clearLines () после вызова freeze (). Мы можем попробовать сыграть и, надеюсь, очистить ряды.

# Гол

Чтобы получить немного больше волнений, нам нужно вести счет. Из руководства Tetris мы получаем следующие значения:

```
const POINTS = {
  SINGLE: 100,
  DOUBLE: 300,
  TRIPLE: 500,
  TETRIS: 800,
  SOFT_DROP: 1,
  HARD_DROP: 2
}
Object.freeze(POINTS);
```
Чтобы отслеживать ход игры, мы добавляем объект accountValues ​​со счетом и линиями. Когда любое из этих значений изменяется, мы хотим изменить его на экране. Мы добавляем универсальную функцию, которая получает элемент из HTML и изменяет его textContext на предоставленное значение.

Чтобы воздействовать на изменения объекта учетной записи, мы можем создать объект Proxy и запустить код для обновления экрана в методе set. Мы отправляем объект accountValues ​​прокси-серверу, потому что это объект, для которого мы хотим иметь пользовательское поведение:

```
let accountValues = {
  score: 0,
  lines: 0
}

function updateAccount(key, value) {
  let element = document.getElementById(key);
  if (element) {
    element.textContent = value;
  }
}

let account = new Proxy(accountValues, {
  set: (target, key, value) => {
    target[key] = value;
    updateAccount(key, value);
    return true;
  }
}
```

Теперь каждый раз, когда мы вызываем свойства учетной записи-посредника, мы вызываем updateAccount () и обновляем DOM. Давайте добавим очки для мягких и жестких перепадов в нашем обработчике событий:

```
if (event.keyCode === KEY.SPACE) {
  while (board.valid(p)) {
    account.score += POINTS.HARD_DROP;
    board.piece.move(p);
    p = moves[KEY.DOWN](board.piece);
  }
} else if (board.valid(p)) {
  board.piece.move(p);
  if (event.keyCode === KEY.DOWN) {
    account.score += POINTS.SOFT_DROP;
  }
}
```

Теперь по линии четких точек. В зависимости от количества линий, мы получаем определенные очки:

```
getLineClearPoints(lines) {  
  return lines === 1 ? Points.SINGLE :
         lines === 2 ? Points.DOUBLE :  
         lines === 3 ? Points.TRIPLE :     
         lines === 4 ? Points.TETRIS : 
         0;
}
```

Чтобы это работало, нам нужно добавить немного логики для подсчета количества очищаемых строк:

```
clearLines() {
  let lines = 0;
  this.board.forEach((row, y) => {    
    if (row.every(value => value !== 0)) {      
      lines++; // Increase for cleared line
      this.board.splice(y, 1); 
      this.board.unshift(Array(COLS).fill(0));
    }  
  });  
  if (lines > 0) {    
    // Add points if we cleared some lines
    account.score += this.getLineClearPoints(lines);  
  }
}
```

Если мы попробуем играть сейчас, мы увидим, что мы увеличиваем наш счет. Нам нужно помнить, что всякий раз, когда мы хотим, чтобы что-то появилось на экране, нам нужно проходить через прокси, а не напрямую к объекту учетной записи.

# Уровни

Когда мы становимся лучше в Тетрисе, скорость, с которой мы начинаем, становится слишком легкой. И слишком легко значит скучно. Поэтому нам нужно повысить уровень сложности. Мы делаем это, уменьшая скорость интервала в нашем игровом цикле.

```
const LINES_PER_LEVEL = 10;

const LEVEL = {
  0: 800,
  1: 720,
  2: 630,
  3: 550,
  // ...
}

Object.freeze(LEVEL);
```

Мы также можем показать игроку, на каком уровне он сейчас находится. Логика отслеживания и отображения уровней и линий такая же, как и для точек. Мы инициализируем значение для них, и когда мы начинаем новую игру, мы должны сбросить их.

Мы можем добавить его к объекту учетной записи:

```
let accountValues = {
  score: 0,
  lines: 0,
  level: 0
}
```

Инициализация игры может идти в функции, которую мы вызываем из play ():

```
function resetGame() {
  account.score = 0;
  account.lines = 0;
  account.level = 0;
  board = this.getEmptyBoard();
}
```

С увеличением уровней появляется больше очков за очистку линии. Мы умножаем точки на текущий уровень и добавляем единицу, поскольку начинаем с нулевого уровня.

```
(account.level + 1) * lineClearPoints;
```

Следующий уровень достигается, когда линии очищаются в соответствии с настройками. Нам также необходимо обновить скорость уровня.

```
if (lines > 0) {
  // Calculate points from cleared lines and level.
  
  account.score += this.getLinesClearedPoints(lines, this.level);
  account.lines += lines;
  
  // If we have reached the lines for next level
  if (account.lines >= LINES_PER_LEVEL) {
    
    // Goto next level
    account.level++;
    
    // Remove lines so we start working for the next level
    account.lines -= LINES_PER_LEVEL;
    
    // Increase speed of game.
    time.level = Level[account.level];
  }
}
```

Теперь, если мы сыграем и очистим десять линий, мы увидим повышение уровня и очки удвоятся. И, конечно, игра начинает двигаться немного быстрее.

# Игра закончена


Если вы играете какое-то время, вы замечаете, что тетромино не перестают падать. Нам нужно знать, когда закончить игру.
После того, как мы выпадем, мы можем проверить, находимся ли мы в строке 0, и в этом случае мы останавливаем игру, выйдя из функции игрового цикла:

```
if (this.piece.y === 0) {
  this.gameOver();
  return;
}
```

Перед выходом мы отменяем ранее запланированный запрос кадра анимации с помощью cancelAnimationFrame. И мы показываем сообщение пользователю.

```
function gameOver() {
  cancelAnimationFrame(requestId);
  this.ctx.fillStyle = 'black';
  this.ctx.fillRect(1, 3, 8, 1.2);
  this.ctx.font = '1px Arial';
  this.ctx.fillStyle = 'red';
  this.ctx.fillText('GAME OVER', 1.8, 4);
}
```

# Следующее тетромино

Давайте добавим еще одну вещь, следующий тетромино. Мы можем добавить еще один холст для этого:

```
<canvas id="next" class=”next”></canvas>
```

Далее мы делаем то же, что и для нашего первого холста:

```
const canvasNext = document.getElementById('next');
const ctxNext = canvasNext.getContext('2d');
// Size canvas for four blocks.
ctxNext.canvas.width = 4 * BLOCK_SIZE;
ctxNext.canvas.height = 4 * BLOCK_SIZE;
ctxNext.scale(BLOCK_SIZE, BLOCK_SIZE);
```

Мы должны немного изменить логику в функции drop. Вместо того, чтобы создавать новый кусок, мы устанавливаем его на следующий и вместо этого создаем новый следующий кусок:

```
this.piece = this.next;
this.next = new Piece(this.ctx);
this.next.drawNext(this.ctxNext);
```

Теперь, когда мы видим, какая часть идет дальше, мы можем быть немного более стратегическими.

# Вывод

Сегодня мы узнали об основах разработки игр и о том, как мы можем использовать Canvas для графики. Я также хотел, чтобы этот проект был интересным способом изучения современного JavaScript. Надеюсь, вам понравилась статья и вы узнали что-то новое для своего инструментария JavaScript.
