# Tetris-JS

Тетрис - отличная игра, чтобы начать наше путешествие в разработке игр. Он содержит основные элементы игр и относительно прост в программировании. Тетромино представляют собой набор из четырех блоков, что делает графику немного проще, чем в большинстве игр.

# Структура проекта

Хорошо разделить код на несколько частей в проекте, даже если он не такой большой. JavaScript находится в четырех разных файлах:

<li><strong>constants.js</strong> - это место, где мы размещаем настройки и правила игры.</li>
<li><strong>board.js</strong> - для доски логики.</li>
<li><strong>piece.js</strong> - для кусок логики.</li>
<li><strong>main.js</strong> - имеет код для инициализации игры и общую игровую логику.</li>
<li><strong>index.html</strong> - порядок сценариев, которые мы добавляем в конце, очень важен.</li>
<li><strong>styles.css</strong> - все украшающие стили здесь.</li>
<li><strong>README.md</strong> - информационный файл, который является первой страницей в хранилище.</li>

# Размер и Стиль

Игровая доска состоит из 10 колонок и 20 рядов. Мы часто используем эти значения для обхода платы, чтобы добавить их в constants.js вместе с размером блоков:

```
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30;
```
Я предпочитаю использовать элемент canvas для графики.

```
<div class="grid">
  <canvas id="board" class="game-board"></canvas>
  <div class="right-column">
    <div>
      <h1>TETRIS</h1>
      <p>Score: <span id="score">0</span></p>
      <p>Lines: <span id="lines">0</span></p>
      <p>Level: <span id="level">0</span></p>
      <canvas id="next" class="next"></canvas>
    </div>
    <button onclick="play()" class="play-button">Play</button>
  </div>
</div>
```

Мы можем получить элемент canvas и его 2d-контекст в main.js и использовать константы для установки размера:

```
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

// Calculate size of canvas from constants.
ctx.canvas.width = COLS * BLOCK_SIZE;
ctx.canvas.height = ROWS * BLOCK_SIZE;

// Scale blocks
ctx.scale(BLOCK_SIZE, BLOCK_SIZE);
```

Используя масштаб, мы всегда можем дать размер блоков как один (1) вместо необходимости везде вычислять с BLOCK_SIZE, что упрощает наш код.

# Стайлинг

Приятно, чтобы в нашей игре было ощущение 80-х. Press Start 2P - это растровый шрифт, основанный на дизайне шрифтов аркадных игр Namco 1980-х годов. Мы можем сослаться на него в <head> и добавить его в наши стили:
  
```
<link 
  href="https://fonts.googleapis.com/css?family=Press+Start+2P" 
  rel="stylesheet"
/>
```

Первый раздел в styles.css предназначен для шрифта в стиле аркады. Обратите внимание на использование CSS Grid и Flexbox для макета:

```
* {
  font-family: 'Press Start 2P', cursive;
}

.grid {
  display: grid;
  grid-template-columns: 320px 200px;
}

.right-column {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.game-board {
  border: solid 2px;
}

.play-button {
  background-color: #4caf50;
  font-size: 16px;
  padding: 15px 30px;
  cursor: pointer;
}
```

Теперь у нас есть стилизованный и готовый игровой контейнер, ожидающий кода.

# Доска

Доска в тетрисе состоит из ячеек, которые либо заняты, либо нет. Моей первой мыслью было представить ячейку с логическими значениями. Но мы можем добиться большего, используя цифры. Мы можем представить пустую ячейку с 0, а цвета с номерами 1–7.

Следующая концепция представляет строки и столбцы игрового поля. Мы можем использовать массив чисел для представления строки. А доска это массив строк. Другими словами, двумерный (2D) массив или то, что мы называем матрицей.

Давайте создадим функцию в board.js, которая возвращает пустую доску со всеми ячейками, установленными на ноль. Метод fill () пригодится здесь:

```
class Board {
  grid;
  
  // Reset the board when we start a new game.
  reset() {
    this.grid = this.getEmptyBoard();
  }
  
  // Get matrix filled with zeros.
  getEmptyBoard() {
    return Array.from(
      {length: ROWS}, () => Array(COLS).fill(0)
    );
  }
}
```

Мы можем вызвать эту функцию в main.js, когда нажимаем play:

```
let board = new Board();

function play() {
  board.reset();
  console.table(board.grid);
}
```

Используя console.table, мы видим представление платы в цифрах.
Координаты X и Y представляют ячейки доски. Теперь, когда у нас есть доска, давайте посмотрим на движущиеся части.

# Тетромино

Фигура в тетрисе - это фигура, состоящая из четырех блоков, которые движутся как единое целое. Их часто называют tetrominos и входят в семь различных образцов и цветов. Имена I, J, L, O, S, T и Z имеют сходство по форме.

Мы представляем J-тетромино в виде матрицы, где число два представляет цветные клетки. Мы добавляем ряд нулей, чтобы центр вращался:

```
[2, 0, 0],
[2, 2, 2],
[0, 0, 0];
```
Мы хотим, чтобы класс Piece знал свое положение на доске, какой у него цвет и как он выглядит. Таким образом, чтобы иметь возможность рисовать себя на доске, ему нужна ссылка на контекст холста.

Для начала мы можем жестко закодировать значения нашего куска:

```
class Piece {
  x;
  y;
  color;
  shape;
  ctx;
  
  constructor(ctx) {
    this.ctx = ctx;
    this.spawn();
  }
  
  spawn() {
    this.color = 'blue';
    this.shape = [
      [2, 0, 0], 
      [2, 2, 2], 
      [0, 0, 0]
    ];
    
    // Starting position.
    this.x = 3;
    this.y = 0;
  }
}
```
Чтобы нарисовать тетромино на доске, мы перебираем все ячейки фигуры. Если значение в ячейке больше нуля, мы окрашиваем этот блок.

```
draw() {
  this.ctx.fillStyle = this.color;
  this.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      // this.x, this.y gives the left upper position of the shape
      // x, y gives the position of the block in the shape
      // this.x + x is then the position of the block on the board
      if (value > 0) {
        this.ctx.fillRect(this.x + x, this.y + y, 1, 1);
      }
    });
  });
}
```

Доска отслеживает тетромино на доске, поэтому мы можем создать и нарисовать ее, когда нажимаем кнопку воспроизведения:

```
function play() {
  board = getEmptyBoard();
  let piece = new Piece(ctx);
  piece.draw();
  
  board.piece = piece;
}
```

# Ввод с клавиатуры

Нам нужно соединить события клавиатуры, чтобы переместить фигуру на доске. Функция перемещения изменяет переменную x или y текущей фигуры, чтобы изменить ее положение на доске.

```
move(p) {
  this.x = p.x;
  this.y = p.y;
}
```

# Перечисления

Далее мы сопоставляем ключи с кодами ключей в constants.js. Для этого было бы неплохо иметь перечисление
В JavaScript нет встроенных перечислений, поэтому давайте создадим их, создав объект со значениями:

```
const KEY = {
  LEFT: 37,
  RIGHT: 39,
  DOWN: 40
}
Object.freeze(KEY);
```
Const может вводить в заблуждение при работе с объектами и массивами и фактически не делает их неизменными. Чтобы достичь этого, мы можем использовать Object.freeze (). Несколько ошибок здесь:

<li>Чтобы это работало правильно, нам нужно использовать строгий режим.</li>
<li>Это работает только на один уровень ниже. Другими словами, если у нас есть массив или объект внутри нашего объекта, то это не замораживает их.</li>

# Объектные литералы

Чтобы сопоставить ключевые события с действиями, мы можем использовать поиск литералов объектов.

Нам нужны скобки, чтобы получить вычисляемые имена свойств, чтобы мы могли использовать наши константы. Это упрощенный пример того, как это работает:

```
const X = 'x';
const a = { [X]: 5 };
console.log(a.x); // 5
```


Мы хотим отправить текущее тетромино и вернуть его копию вместе с изменением координат. Для этого мы можем использовать оператор распространения, чтобы получить мелкую копию, а затем изменить координаты на желаемое положение.
